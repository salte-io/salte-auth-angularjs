{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth-angular.min.js","webpack:///webpack/bootstrap 7cc756494531cf041608","webpack:///./protected-resource-interceptor.factory.js","webpack:///./salte-auth.provider.js","webpack:///external \"angular\"","webpack:///external \"salte-auth\"","webpack:///./salte-auth-angular.module.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","ProtectedResourceInterceptor","salteAuthService","$q","$rootScope","request","config","_ret","headers","resource","getResourceForEndpoint","url","verbose","v","tokenStored","getCachedToken","info","Authorization","delayedRequest","loginInProgress","popUp","defer","$on","event","token","resolve","promise","data","reject","acquireToken","then","err","_typeof","responseError","rejection","status","clearCacheForResource","$broadcast","Symbol","iterator","obj","constructor","default","$inject","_interopRequireDefault","salteAuth","_oauthData","isAuthenticated","userName","loginError","profile","updateDataFromCache","length","user","getCachedUser","getLoginError","init","configOptions","httpProvider","Error","existingHash","window","location","hash","pathDefault","href","replace","redirectUri","postLogoutRedirectUri","isAngular","interceptors","push","_salteAuth2","loginResource","$get","$window","$location","$timeout","$injector","isADLoginRequired","route","global","requireAuthentication","Boolean","isAnonymousEndpoint","anonymousEndpoints","indexOf","getStates","toState","state","states","unshift","parent","stateNames","split","stateName","locationChangeHandler","newUrl","oldUrl","search","isCallback","requestInfo","getRequestInfo","saveTokenFromHash","stateMatch","requestType","REQUEST_TYPE","RENEW_TOKEN","callback","AuthenticationContext","callBackMappedToRenewStates","stateResponse","preventDefault","parameters","access_token","_getItem","CONSTANTS","STORAGE","ERROR_DESCRIPTION","id_token","error","LOGIN","userInfo","IDTOKEN","loginStartPage","LOGIN_REQUEST","$$html5","substring","_renewActive","tokenOut","loginHandler","$$url","localLoginUrl","path","login","absUrl","routeChangeHandler","e","nextRoute","$$route","nextRouteUrl","templateUrl","params","stateChangeHandler","toParams","fromState","fromParams","nextStateUrl","stateChangeErrorHandler","logOut","deferred","getUser","endpoint","clearCache","message","_salteAuth","_angular","_angular2","_protectedResourceInterceptorFactory","_protectedResourceInterceptorFactory2","_salteAuthProvider","_salteAuthProvider2","provider"],"mappings":"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","file":"salte-auth-angular.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth-angular\", [\"angular\", \"salte-auth\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth-angular\"] = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse\n\t\troot[\"salte-auth-angular\"] = factory(root[\"angular\"], root[\"salte-auth\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/**\n * salte-auth-angular JavaScript Library v1.0.14\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with â™¥ by Dave Woodward <dave@salte.io>, Nick Woodward <nick@salte.io\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth-angular\", [\"angular\", \"salte-auth\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth-angular\"] = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse\n\t\troot[\"salte-auth-angular\"] = factory(root[\"angular\"], root[\"salte-auth\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = ProtectedResourceInterceptor;\n/* @ngInject */\nfunction ProtectedResourceInterceptor(salteAuthService, $q, $rootScope) {\n  return {\n    request: function request(config) {\n      if (config) {\n        var _ret = function () {\n          config.headers = config.headers || {};\n          var resource = salteAuthService.getResourceForEndpoint(config.url);\n          salteAuthService.verbose('Url: ' + config.url + ' maps to resource: ' + resource);\n\n          if (resource === null) {\n            return {\n              v: config\n            };\n          }\n\n          var tokenStored = salteAuthService.getCachedToken(resource);\n          if (tokenStored) {\n            salteAuthService.info('Token is available for this url ' + config.url);\n            // check endpoint mapping if provided\n            config.headers.Authorization = 'Bearer ' + tokenStored;\n            return {\n              v: config\n            };\n          }\n\n          // Cancel request if login is starting\n          var delayedRequest = void 0;\n          if (salteAuthService.loginInProgress()) {\n            if (salteAuthService.config.popUp) {\n              salteAuthService.info('Url: ' + config.url + ' will be loaded after login is successful');\n              delayedRequest = $q.defer();\n              $rootScope.$on('salte-auth:loginSuccess', function (event, token) {\n                if (token) {\n                  salteAuthService.info('Login completed, sending request for ' + config.url);\n                  config.headers.Authorization = 'Bearer ' + tokenStored;\n                  delayedRequest.resolve(config);\n                }\n              });\n              return {\n                v: delayedRequest.promise\n              };\n            }\n\n            salteAuthService.info('login is in progress.');\n            config.data = 'login in progress, cancelling the request for ' + config.url;\n            return {\n              v: $q.reject(config)\n            };\n          }\n\n          // delayed request to return after iframe completes\n          delayedRequest = $q.defer();\n          salteAuthService.acquireToken(resource).then(function (token) {\n            salteAuthService.verbose('Token is available');\n            config.headers.Authorization = 'Bearer ' + token;\n            delayedRequest.resolve(config);\n          }, function (err) {\n            config.data = err;\n            delayedRequest.reject(config);\n          });\n\n          return {\n            v: delayedRequest.promise\n          };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    },\n    responseError: function responseError(rejection) {\n      salteAuthService.info('Getting error in the response.');\n      if (rejection) {\n        if (rejection.status === 401) {\n          var resource = salteAuthService.getResourceForEndpoint(rejection.config.url);\n          salteAuthService.clearCacheForResource(resource);\n          $rootScope.$broadcast('salte-auth:notAuthorized', rejection, resource);\n        } else {\n          $rootScope.$broadcast('salte-auth:errorResponse', rejection);\n        }\n        return $q.reject(rejection);\n      }\n    }\n  };\n}\n\nProtectedResourceInterceptor.$inject = ['salteAuthService', '$q', '$rootScope'];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function () {\n  var salteAuth = null;\n  var _oauthData = {\n    isAuthenticated: false,\n    userName: '',\n    loginError: '',\n    profile: ''\n  };\n\n  var updateDataFromCache = function updateDataFromCache(resource) {\n    // only cache lookup here to not interrupt with events\n    var token = salteAuth.getCachedToken(resource);\n    _oauthData.isAuthenticated = token !== null && token.length > 0;\n    var user = salteAuth.getCachedUser() || {\n      userName: ''\n    };\n    _oauthData.userName = user.userName;\n    _oauthData.profile = user.profile;\n    _oauthData.loginError = salteAuth.getLoginError();\n  };\n\n  this.init = function (configOptions, httpProvider) {\n    if (configOptions) {\n      // redirect and logout_redirect are set to current location by default\n      var existingHash = window.location.hash;\n      var pathDefault = window.location.href;\n      if (existingHash) {\n        pathDefault = pathDefault.replace(existingHash, '');\n      }\n      configOptions.redirectUri = configOptions.redirectUri || pathDefault;\n      configOptions.postLogoutRedirectUri = configOptions.postLogoutRedirectUri || pathDefault;\n      configOptions.isAngular = true;\n\n      if (httpProvider && httpProvider.interceptors) {\n        httpProvider.interceptors.push('ProtectedResourceInterceptor');\n      }\n\n      // create instance with given config\n      salteAuth = new _salteAuth2.default(configOptions);\n    } else {\n      throw new Error('You must set configOptions, when calling init');\n    }\n\n    // loginResource is used to set authenticated status\n    updateDataFromCache(salteAuth.config.loginResource);\n  };\n\n  /* @ngInject */\n  this.$get = function SalteAuthService($rootScope, $window, $q, $location, $timeout, $injector) {\n    var locationChangeHandler = function locationChangeHandler(event, newUrl, oldUrl) {\n      salteAuth.verbose('Location change event from ' + oldUrl + ' to ' + newUrl);\n      var hash = $window.location.hash;\n      var search = $window.location.search;\n\n      if (salteAuth.isCallback(hash, search)) {\n        // callback can come from login or iframe request\n        salteAuth.verbose('Processing Callback, Hash: ' + hash + '; Search String: ' + search);\n        var requestInfo = salteAuth.getRequestInfo(hash, search);\n        salteAuth.saveTokenFromHash(requestInfo);\n\n        // Return to callback if it is sent from iframe\n        if (requestInfo.stateMatch) {\n          if (requestInfo.requestType === salteAuth.REQUEST_TYPE.RENEW_TOKEN) {\n            var callback = $window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n            // since this is a token renewal request in iFrame, we don't need to proceed with the location change.\n            event.preventDefault();\n\n            // Call within the same context without full page redirect keeps the callback\n            if (callback && typeof callback === 'function') {\n              // id_token or access_token can be renewed\n              if (requestInfo.parameters.access_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.access_token);\n                return;\n              } else if (requestInfo.parameters.id_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.id_token);\n                return;\n              } else if (requestInfo.parameters.error) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), null);\n                return;\n              }\n            }\n          } else if (requestInfo.requestType === salteAuth.REQUEST_TYPE.LOGIN) {\n            // normal full login redirect happened on the page\n            updateDataFromCache(salteAuth.config.loginResource);\n            if (_oauthData.userName) {\n              $timeout(function () {\n                // id_token is added as token for the app\n                updateDataFromCache(salteAuth.config.loginResource);\n                $rootScope.userInfo = _oauthData;\n              }, 1);\n\n              $rootScope.$broadcast('salte-auth:loginSuccess', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            } else {\n              $rootScope.$broadcast('salte-auth:loginFailure', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n            }\n\n            if (salteAuth.callback && typeof salteAuth.callback === 'function') {\n              salteAuth.callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            }\n\n            // redirect to login start page\n            if (!salteAuth.popUp) {\n              var loginStartPage = salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.LOGIN_REQUEST);\n              if (typeof loginStartPage !== 'undefined' && loginStartPage && loginStartPage.length !== 0) {\n                // prevent the current location change and redirect the user back to the login start page\n                salteAuth.verbose('Redirecting to start page: ' + loginStartPage);\n                if (!$location.$$html5 && loginStartPage.indexOf('#') > -1) {\n                  $location.url(loginStartPage.substring(loginStartPage.indexOf('#') + 1));\n                }\n                $window.location = loginStartPage;\n              }\n            } else {\n              event.preventDefault();\n            }\n          }\n        } else {\n          // state did not match, broadcast an error\n          $rootScope.$broadcast('salte-auth:stateMismatch', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n        }\n      } else {\n        // No callback. App resumes after closing or moving to new page.\n        // Check token and username\n        updateDataFromCache(salteAuth.config.loginResource);\n        if (!_oauthData.isAuthenticated && _oauthData.userName && !salteAuth._renewActive) {\n          // id_token is expired or not present\n          salteAuth._renewActive = true;\n          salteAuth.acquireToken(salteAuth.config.loginResource, function (error, tokenOut) {\n            salteAuth._renewActive = false;\n            if (error) {\n              $rootScope.$broadcast('salte-auth:loginFailure', 'auto renew failure');\n            } else if (tokenOut) {\n              _oauthData.isAuthenticated = true;\n            }\n          });\n        }\n      }\n\n      $timeout(function () {\n        updateDataFromCache(salteAuth.config.loginResource);\n        $rootScope.userInfo = _oauthData;\n      }, 1);\n    };\n\n    var loginHandler = function loginHandler() {\n      salteAuth.info('Login event for:' + $location.$$url);\n      if (salteAuth.config && salteAuth.config.localLoginUrl) {\n        $location.path(salteAuth.config.localLoginUrl);\n      } else {\n        // directly start login flow\n        salteAuth.info('Start login at:' + window.location.href);\n        $rootScope.$broadcast('salte-auth:loginRedirect');\n        salteAuth.login($location.absUrl());\n      }\n    };\n\n    function isADLoginRequired(route, global) {\n      return global.requireAuthentication ? route.requireAuthentication !== false : Boolean(route.requireAuthentication);\n    }\n\n    function isAnonymousEndpoint(url) {\n      if (salteAuth.config && salteAuth.config.anonymousEndpoints) {\n        for (var i = 0; i < salteAuth.config.anonymousEndpoints.length; i++) {\n          if (url.indexOf(salteAuth.config.anonymousEndpoints[i]) > -1) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function getStates(toState) {\n      var state = null;\n      var states = [];\n      if (toState.hasOwnProperty('parent')) {\n        state = toState;\n        while (state) {\n          states.unshift(state);\n          state = $injector.get('$state').get(state.parent);\n        }\n      } else {\n        var stateNames = toState.name.split('.');\n        for (var i = 0, stateName = stateNames[0]; i < stateNames.length; i++) {\n          state = $injector.get('$state').get(stateName);\n          if (state) {\n            states.push(state);\n          }\n          stateName += '.' + stateNames[i + 1];\n        }\n      }\n      return states;\n    }\n\n    var routeChangeHandler = function routeChangeHandler(e, nextRoute) {\n      if (nextRoute && nextRoute.$$route) {\n        if (isADLoginRequired(nextRoute.$$route, salteAuth.config)) {\n          if (!_oauthData.isAuthenticated) {\n            if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n              salteAuth.info('Route change event for:' + $location.$$url);\n              loginHandler();\n            }\n          }\n        } else {\n          var nextRouteUrl = void 0;\n          if (typeof nextRoute.$$route.templateUrl === 'function') {\n            nextRouteUrl = nextRoute.$$route.templateUrl(nextRoute.params);\n          } else {\n            nextRouteUrl = nextRoute.$$route.templateUrl;\n          }\n\n          if (nextRouteUrl && !isAnonymousEndpoint(nextRouteUrl)) {\n            salteAuth.config.anonymousEndpoints.push(nextRouteUrl);\n          }\n        }\n      }\n    };\n\n    var stateChangeHandler = function stateChangeHandler(e, toState, toParams, fromState, fromParams) {\n      // jshint ignore:line\n      if (toState) {\n        var states = getStates(toState);\n        var state = null;\n        for (var i = 0; i < states.length; i++) {\n          state = states[i];\n          if (isADLoginRequired(state, salteAuth.config)) {\n            if (!_oauthData.isAuthenticated) {\n              if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n                salteAuth.info('State change event for:' + $location.$$url);\n                loginHandler();\n              }\n            }\n          } else if (state.templateUrl) {\n            var nextStateUrl = void 0;\n            if (typeof state.templateUrl === 'function') {\n              nextStateUrl = state.templateUrl(toParams);\n            } else {\n              nextStateUrl = state.templateUrl;\n            }\n            if (nextStateUrl && !isAnonymousEndpoint(nextStateUrl)) {\n              salteAuth.config.anonymousEndpoints.push(nextStateUrl);\n            }\n          }\n        }\n      }\n    };\n\n    var stateChangeErrorHandler = function stateChangeErrorHandler(event, toState, toParams, fromState, fromParams, error) {\n      salteAuth.verbose('State change error occured. Error: ' + error);\n\n      if (error && error.data) {\n        salteAuth.info('Setting defaultPrevented to true if state change error occured because the request was rejected. Error: ' + error.data);\n        event.preventDefault();\n      }\n    };\n\n    // Route change event tracking to receive fragment and also auto renew tokens\n    $rootScope.$on('$routeChangeStart', routeChangeHandler);\n\n    $rootScope.$on('$stateChangeStart', stateChangeHandler);\n\n    $rootScope.$on('$locationChangeStart', locationChangeHandler);\n\n    $rootScope.$on('$stateChangeError', stateChangeErrorHandler);\n\n    updateDataFromCache(salteAuth.config.loginResource);\n    $rootScope.userInfo = _oauthData;\n\n    return {\n      // public methods will be here that are accessible from Controller\n      config: salteAuth.config,\n      login: function login() {\n        loginHandler();\n      },\n      loginInProgress: function loginInProgress() {\n        return salteAuth.loginInProgress();\n      },\n      logOut: function logOut() {\n        salteAuth.logOut();\n        // call signout related method\n      },\n      getCachedToken: function getCachedToken(resource) {\n        return salteAuth.getCachedToken(resource);\n      },\n      userInfo: _oauthData,\n      acquireToken: function acquireToken(resource) {\n        // automated token request call\n        var deferred = $q.defer();\n        salteAuth._renewActive = true;\n        salteAuth.acquireToken(resource, function (error, tokenOut) {\n          salteAuth._renewActive = false;\n          if (error) {\n            salteAuth.error('Error when acquiring token for resource: ' + resource, error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(tokenOut);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getUser: function getUser() {\n        var deferred = $q.defer();\n        salteAuth.getUser(function (error, user) {\n          if (error) {\n            salteAuth.error('Error when getting user', error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(user);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getResourceForEndpoint: function getResourceForEndpoint(endpoint) {\n        return salteAuth.getResourceForEndpoint(endpoint);\n      },\n      clearCache: function clearCache() {\n        salteAuth.clearCache();\n      },\n      clearCacheForResource: function clearCacheForResource(resource) {\n        salteAuth.clearCacheForResource(resource);\n      },\n      info: function info(message) {\n        salteAuth.info(message);\n      },\n      verbose: function verbose(message) {\n        salteAuth.verbose(message);\n      },\n      salteAuth: salteAuth\n    };\n  };\n  this.$get.$inject = ['$rootScope', '$window', '$q', '$location', '$timeout', '$injector'];\n};\n\nvar _salteAuth = __webpack_require__(3);\n\nvar _salteAuth2 = _interopRequireDefault(_salteAuth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _angular = __webpack_require__(2);\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _protectedResourceInterceptorFactory = __webpack_require__(0);\n\nvar _protectedResourceInterceptorFactory2 = _interopRequireDefault(_protectedResourceInterceptorFactory);\n\nvar _salteAuthProvider = __webpack_require__(1);\n\nvar _salteAuthProvider2 = _interopRequireDefault(_salteAuthProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _module = _angular2.default.module('salte.auth-angular', []);\n\n_module.factory('ProtectedResourceInterceptor', _protectedResourceInterceptorFactory2.default);\n_module.provider('salteAuthService', _salteAuthProvider2.default);\n\nexports.default = _module.name;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// salte-auth-angular.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7cc756494531cf041608","/* @ngInject */\nexport default function ProtectedResourceInterceptor(salteAuthService, $q, $rootScope) {\n  return {\n    request: function(config) {\n      if (config) {\n        config.headers = config.headers || {};\n        let resource = salteAuthService.getResourceForEndpoint(config.url);\n        salteAuthService.verbose('Url: ' + config.url + ' maps to resource: ' + resource);\n\n        if (resource === null) {\n          return config;\n        }\n\n        let tokenStored = salteAuthService.getCachedToken(resource);\n        if (tokenStored) {\n          salteAuthService.info('Token is available for this url ' + config.url);\n          // check endpoint mapping if provided\n          config.headers.Authorization = 'Bearer ' + tokenStored;\n          return config;\n        }\n\n        // Cancel request if login is starting\n        let delayedRequest;\n        if (salteAuthService.loginInProgress()) {\n          if (salteAuthService.config.popUp) {\n            salteAuthService.info('Url: ' + config.url + ' will be loaded after login is successful');\n            delayedRequest = $q.defer();\n            $rootScope.$on('salte-auth:loginSuccess', function(event, token) {\n              if (token) {\n                salteAuthService.info('Login completed, sending request for ' + config.url);\n                config.headers.Authorization = 'Bearer ' + tokenStored;\n                delayedRequest.resolve(config);\n              }\n            });\n            return delayedRequest.promise;\n          }\n\n          salteAuthService.info('login is in progress.');\n          config.data = 'login in progress, cancelling the request for ' + config.url;\n          return $q.reject(config);\n        }\n\n        // delayed request to return after iframe completes\n        delayedRequest = $q.defer();\n        salteAuthService.acquireToken(resource).then(function(token) {\n          salteAuthService.verbose('Token is available');\n          config.headers.Authorization = 'Bearer ' + token;\n          delayedRequest.resolve(config);\n        }, function(err) {\n          config.data = err;\n          delayedRequest.reject(config);\n        });\n\n        return delayedRequest.promise;\n      }\n    },\n    responseError: function(rejection) {\n      salteAuthService.info('Getting error in the response.');\n      if (rejection) {\n        if (rejection.status === 401) {\n          let resource = salteAuthService.getResourceForEndpoint(rejection.config.url);\n          salteAuthService.clearCacheForResource(resource);\n          $rootScope.$broadcast('salte-auth:notAuthorized', rejection, resource);\n        } else {\n          $rootScope.$broadcast('salte-auth:errorResponse', rejection);\n        }\n        return $q.reject(rejection);\n      }\n    }\n  };\n}\n\nProtectedResourceInterceptor.$inject = ['salteAuthService', '$q', '$rootScope'];\n\n\n\n// WEBPACK FOOTER //\n// ./protected-resource-interceptor.factory.js","import SalteAuth from 'salte-auth';\n\nexport default function() {\n  let salteAuth = null;\n  let _oauthData = {\n    isAuthenticated: false,\n    userName: '',\n    loginError: '',\n    profile: ''\n  };\n\n  let updateDataFromCache = function(resource) {\n    // only cache lookup here to not interrupt with events\n    let token = salteAuth.getCachedToken(resource);\n    _oauthData.isAuthenticated = token !== null && token.length > 0;\n    let user = salteAuth.getCachedUser() || {\n      userName: ''\n    };\n    _oauthData.userName = user.userName;\n    _oauthData.profile = user.profile;\n    _oauthData.loginError = salteAuth.getLoginError();\n  };\n\n  this.init = function(configOptions, httpProvider) {\n    if (configOptions) {\n      // redirect and logout_redirect are set to current location by default\n      let existingHash = window.location.hash;\n      let pathDefault = window.location.href;\n      if (existingHash) {\n        pathDefault = pathDefault.replace(existingHash, '');\n      }\n      configOptions.redirectUri = configOptions.redirectUri || pathDefault;\n      configOptions.postLogoutRedirectUri = configOptions.postLogoutRedirectUri || pathDefault;\n      configOptions.isAngular = true;\n\n      if (httpProvider && httpProvider.interceptors) {\n        httpProvider.interceptors.push('ProtectedResourceInterceptor');\n      }\n\n      // create instance with given config\n      salteAuth = new SalteAuth(configOptions);\n    } else {\n      throw new Error('You must set configOptions, when calling init');\n    }\n\n    // loginResource is used to set authenticated status\n    updateDataFromCache(salteAuth.config.loginResource);\n  };\n\n  /* @ngInject */\n  this.$get = function SalteAuthService($rootScope, $window, $q, $location, $timeout, $injector) {\n    let locationChangeHandler = function(event, newUrl, oldUrl) {\n      salteAuth.verbose('Location change event from ' + oldUrl + ' to ' + newUrl);\n      let hash = $window.location.hash;\n      let search = $window.location.search;\n\n      if (salteAuth.isCallback(hash, search)) {\n        // callback can come from login or iframe request\n        salteAuth.verbose('Processing Callback, Hash: ' + hash + '; Search String: ' + search);\n        let requestInfo = salteAuth.getRequestInfo(hash, search);\n        salteAuth.saveTokenFromHash(requestInfo);\n\n        // Return to callback if it is sent from iframe\n        if (requestInfo.stateMatch) {\n          if (requestInfo.requestType === salteAuth.REQUEST_TYPE.RENEW_TOKEN) {\n            let callback = $window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n            // since this is a token renewal request in iFrame, we don't need to proceed with the location change.\n            event.preventDefault();\n\n            // Call within the same context without full page redirect keeps the callback\n            if (callback && typeof callback === 'function') {\n              // id_token or access_token can be renewed\n              if (requestInfo.parameters.access_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.access_token);\n                return;\n              } else if (requestInfo.parameters.id_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.id_token);\n                return;\n              } else if (requestInfo.parameters.error) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), null);\n                return;\n              }\n            }\n          } else if (requestInfo.requestType === salteAuth.REQUEST_TYPE.LOGIN) {\n            // normal full login redirect happened on the page\n            updateDataFromCache(salteAuth.config.loginResource);\n            if (_oauthData.userName) {\n              $timeout(function() {\n                // id_token is added as token for the app\n                updateDataFromCache(salteAuth.config.loginResource);\n                $rootScope.userInfo = _oauthData;\n              }, 1);\n\n              $rootScope.$broadcast('salte-auth:loginSuccess', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            } else {\n              $rootScope.$broadcast('salte-auth:loginFailure', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n            }\n\n            if (salteAuth.callback && typeof salteAuth.callback === 'function') {\n              salteAuth.callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            }\n\n            // redirect to login start page\n            if (!salteAuth.popUp) {\n              let loginStartPage = salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.LOGIN_REQUEST);\n              if (typeof loginStartPage !== 'undefined' && loginStartPage && loginStartPage.length !== 0) {\n                // prevent the current location change and redirect the user back to the login start page\n                salteAuth.verbose('Redirecting to start page: ' + loginStartPage);\n                if (!$location.$$html5 && loginStartPage.indexOf('#') > -1) {\n                  $location.url(loginStartPage.substring(loginStartPage.indexOf('#') + 1));\n                }\n                $window.location = loginStartPage;\n              }\n            } else {\n              event.preventDefault();\n            }\n          }\n        } else {\n          // state did not match, broadcast an error\n          $rootScope.$broadcast('salte-auth:stateMismatch', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n        }\n      } else {\n        // No callback. App resumes after closing or moving to new page.\n        // Check token and username\n        updateDataFromCache(salteAuth.config.loginResource);\n        if (!_oauthData.isAuthenticated && _oauthData.userName && !salteAuth._renewActive) {\n          // id_token is expired or not present\n          salteAuth._renewActive = true;\n          salteAuth.acquireToken(salteAuth.config.loginResource, function(error, tokenOut) {\n            salteAuth._renewActive = false;\n            if (error) {\n              $rootScope.$broadcast('salte-auth:loginFailure', 'auto renew failure');\n            } else if (tokenOut) {\n              _oauthData.isAuthenticated = true;\n            }\n          });\n        }\n      }\n\n      $timeout(function() {\n        updateDataFromCache(salteAuth.config.loginResource);\n        $rootScope.userInfo = _oauthData;\n      }, 1);\n    };\n\n    let loginHandler = function() {\n      salteAuth.info('Login event for:' + $location.$$url);\n      if (salteAuth.config && salteAuth.config.localLoginUrl) {\n        $location.path(salteAuth.config.localLoginUrl);\n      } else {\n        // directly start login flow\n        salteAuth.info('Start login at:' + window.location.href);\n        $rootScope.$broadcast('salte-auth:loginRedirect');\n        salteAuth.login($location.absUrl());\n      }\n    };\n\n    function isADLoginRequired(route, global) {\n      return global.requireAuthentication ? route.requireAuthentication !== false : Boolean(route.requireAuthentication);\n    }\n\n    function isAnonymousEndpoint(url) {\n      if (salteAuth.config && salteAuth.config.anonymousEndpoints) {\n        for (let i = 0; i < salteAuth.config.anonymousEndpoints.length; i++) {\n          if (url.indexOf(salteAuth.config.anonymousEndpoints[i]) > -1) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function getStates(toState) {\n      let state = null;\n      let states = [];\n      if (toState.hasOwnProperty('parent')) {\n        state = toState;\n        while (state) {\n          states.unshift(state);\n          state = $injector.get('$state').get(state.parent);\n        }\n      } else {\n        let stateNames = toState.name.split('.');\n        for (let i = 0, stateName = stateNames[0]; i < stateNames.length; i++) {\n          state = $injector.get('$state').get(stateName);\n          if (state) {\n            states.push(state);\n          }\n          stateName += '.' + stateNames[i + 1];\n        }\n      }\n      return states;\n    }\n\n    let routeChangeHandler = function(e, nextRoute) {\n      if (nextRoute && nextRoute.$$route) {\n        if (isADLoginRequired(nextRoute.$$route, salteAuth.config)) {\n          if (!_oauthData.isAuthenticated) {\n            if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n              salteAuth.info('Route change event for:' + $location.$$url);\n              loginHandler();\n            }\n          }\n        } else {\n          let nextRouteUrl;\n          if (typeof nextRoute.$$route.templateUrl === 'function') {\n            nextRouteUrl = nextRoute.$$route.templateUrl(nextRoute.params);\n          } else {\n            nextRouteUrl = nextRoute.$$route.templateUrl;\n          }\n\n          if (nextRouteUrl && !isAnonymousEndpoint(nextRouteUrl)) {\n            salteAuth.config.anonymousEndpoints.push(nextRouteUrl);\n          }\n        }\n      }\n    };\n\n    let stateChangeHandler = function(e, toState, toParams, fromState, fromParams) { // jshint ignore:line\n      if (toState) {\n        let states = getStates(toState);\n        let state = null;\n        for (let i = 0; i < states.length; i++) {\n          state = states[i];\n          if (isADLoginRequired(state, salteAuth.config)) {\n            if (!_oauthData.isAuthenticated) {\n              if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n                salteAuth.info('State change event for:' + $location.$$url);\n                loginHandler();\n              }\n            }\n          } else if (state.templateUrl) {\n            let nextStateUrl;\n            if (typeof state.templateUrl === 'function') {\n              nextStateUrl = state.templateUrl(toParams);\n            } else {\n              nextStateUrl = state.templateUrl;\n            }\n            if (nextStateUrl && !isAnonymousEndpoint(nextStateUrl)) {\n              salteAuth.config.anonymousEndpoints.push(nextStateUrl);\n            }\n          }\n        }\n      }\n    };\n\n    let stateChangeErrorHandler = function(event, toState, toParams, fromState, fromParams, error) {\n      salteAuth.verbose('State change error occured. Error: ' + error);\n\n      if (error && error.data) {\n        salteAuth.info('Setting defaultPrevented to true if state change error occured because the request was rejected. Error: ' + error.data);\n        event.preventDefault();\n      }\n    };\n\n    // Route change event tracking to receive fragment and also auto renew tokens\n    $rootScope.$on('$routeChangeStart', routeChangeHandler);\n\n    $rootScope.$on('$stateChangeStart', stateChangeHandler);\n\n    $rootScope.$on('$locationChangeStart', locationChangeHandler);\n\n    $rootScope.$on('$stateChangeError', stateChangeErrorHandler);\n\n    updateDataFromCache(salteAuth.config.loginResource);\n    $rootScope.userInfo = _oauthData;\n\n    return {\n      // public methods will be here that are accessible from Controller\n      config: salteAuth.config,\n      login: function() {\n        loginHandler();\n      },\n      loginInProgress: function() {\n        return salteAuth.loginInProgress();\n      },\n      logOut: function() {\n        salteAuth.logOut();\n        // call signout related method\n      },\n      getCachedToken: function(resource) {\n        return salteAuth.getCachedToken(resource);\n      },\n      userInfo: _oauthData,\n      acquireToken: function(resource) {\n        // automated token request call\n        let deferred = $q.defer();\n        salteAuth._renewActive = true;\n        salteAuth.acquireToken(resource, function(error, tokenOut) {\n          salteAuth._renewActive = false;\n          if (error) {\n            salteAuth.error('Error when acquiring token for resource: ' + resource, error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(tokenOut);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getUser: function() {\n        let deferred = $q.defer();\n        salteAuth.getUser(function(error, user) {\n          if (error) {\n            salteAuth.error('Error when getting user', error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(user);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getResourceForEndpoint: function(endpoint) {\n        return salteAuth.getResourceForEndpoint(endpoint);\n      },\n      clearCache: function() {\n        salteAuth.clearCache();\n      },\n      clearCacheForResource: function(resource) {\n        salteAuth.clearCacheForResource(resource);\n      },\n      info: function(message) {\n        salteAuth.info(message);\n      },\n      verbose: function(message) {\n        salteAuth.verbose(message);\n      },\n      salteAuth: salteAuth\n    };\n  };\n  this.$get.$inject = ['$rootScope', '$window', '$q', '$location', '$timeout', '$injector'];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.provider.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"salte-auth\"\n// module id = 3\n// module chunks = 0","import angular from 'angular';\nimport ProtectedResourceInterceptor from './protected-resource-interceptor.factory.js';\nimport salteAuthService from './salte-auth.provider.js';\n\nconst module = angular.module('salte.auth-angular', []);\n\nmodule.factory('ProtectedResourceInterceptor', ProtectedResourceInterceptor);\nmodule.provider('salteAuthService', salteAuthService);\n\nexport default module.name;\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth-angular.module.js"],"sourceRoot":""}
