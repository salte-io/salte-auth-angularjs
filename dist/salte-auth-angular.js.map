{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth-angular.js","webpack:///webpack/bootstrap 0e498030639eee14a244","webpack:///./salte-auth-angular.module.js","webpack:///./protected-resource-interceptor.factory.js","webpack:///./salte-auth.provider.js","webpack:///external {\"root\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\",\"amd\":\"angular\"}","webpack:///external {\"root\":\"salte-auth\",\"commonjs2\":\"salte-auth\",\"commonjs\":\"salte-auth\",\"amd\":\"salte-auth\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_4__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_angular","_angular2","_protectedResourceInterceptorFactory","_protectedResourceInterceptorFactory2","_salteAuthProvider","_salteAuthProvider2","provider","name","ProtectedResourceInterceptor","salteAuthService","$q","$rootScope","request","config","headers","resource","getResourceForEndpoint","url","verbose","tokenStored","getCachedToken","info","Authorization","popUp","delayedRequest","defer","$on","event","token","resolve","promise","reject","acquireToken","then","err","rejection","clearCacheForResource","$broadcast","$inject","salteAuth","_oauthData","isAuthenticated","userName","loginError","profile","updateDataFromCache","length","user","getCachedUser","getLoginError","init","configOptions","httpProvider","Error","existingHash","window","location","hash","pathDefault","href","replace","redirectUri","postLogoutRedirectUri","isAngular","interceptors","push","_salteAuth2","loginResource","$get","$window","$location","$timeout","$injector","isADLoginRequired","route","global","requireADLogin","Boolean","isAnonymousEndpoint","anonymousEndpoints","i","indexOf","getStates","toState","state","states","hasOwnProperty","unshift","get","parent","stateNames","split","stateName","locationChangeHandler","newUrl","oldUrl","search","isCallback","requestInfo","getRequestInfo","saveTokenFromHash","stateMatch","requestType","REQUEST_TYPE","RENEW_TOKEN","callback","callBackMappedToRenewStates","stateResponse","preventDefault","parameters","access_token","_getItem","CONSTANTS","STORAGE","ERROR_DESCRIPTION","id_token","error","LOGIN","userInfo","IDTOKEN","loginStartPage","LOGIN_REQUEST","$$html5","substring","_renewActive","tokenOut","loginHandler","$$url","localLoginUrl","path","login","absUrl","routeChangeHandler","e","nextRoute","$$route","loginInProgress","nextRouteUrl","templateUrl","params","stateChangeHandler","toParams","fromState","fromParams","nextStateUrl","stateChangeErrorHandler","data","logOut","deferred","getUser","endpoint","clearCache","message","_salteAuth"],"mappings":"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","file":"salte-auth-angular.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth-angular\", [\"angular\", \"salte-auth\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth-angular\"] = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse\n\t\troot[\"salte-auth-angular\"] = factory(root[\"angular\"], root[\"salte-auth\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth-angular\", [\"angular\", \"salte-auth\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth-angular\"] = factory(require(\"angular\"), require(\"salte-auth\"));\n\telse\n\t\troot[\"salte-auth-angular\"] = factory(root[\"angular\"], root[\"salte-auth\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(3);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _protectedResourceInterceptorFactory = __webpack_require__(1);\n\t\n\tvar _protectedResourceInterceptorFactory2 = _interopRequireDefault(_protectedResourceInterceptorFactory);\n\t\n\tvar _salteAuthProvider = __webpack_require__(2);\n\t\n\tvar _salteAuthProvider2 = _interopRequireDefault(_salteAuthProvider);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar _module = _angular2.default.module('salte.auth-angular', []);\n\t\n\t_module.factory('ProtectedResourceInterceptor', _protectedResourceInterceptorFactory2.default);\n\t_module.provider('salteAuthService', _salteAuthProvider2.default);\n\t\n\texports.default = _module.name;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tProtectedResourceInterceptor.$inject = [\"salteAuthService\", \"$q\", \"$rootScope\"];\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = ProtectedResourceInterceptor;\n\t/* @ngInject */\n\tfunction ProtectedResourceInterceptor(salteAuthService, $q, $rootScope) {\n\t  return {\n\t    request: function request(config) {\n\t      if (config) {\n\t        config.headers = config.headers || {};\n\t        var resource = salteAuthService.getResourceForEndpoint(config.url);\n\t        salteAuthService.verbose('Url: ' + config.url + ' maps to resource: ' + resource);\n\t\n\t        if (resource === null) {\n\t          return config;\n\t        }\n\t\n\t        var tokenStored = salteAuthService.getCachedToken(resource);\n\t        if (tokenStored) {\n\t          salteAuthService.info('Token is available for this url ' + config.url);\n\t          // check endpoint mapping if provided\n\t          config.headers.Authorization = 'Bearer ' + tokenStored;\n\t          return config;\n\t        }\n\t\n\t        // Cancel request if login is starting\n\t        var delayedRequest;\n\t        if (salteAuthService.loginInProgress()) {\n\t          if (salteAuthService.config.popUp) {\n\t            salteAuthService.info('Url: ' + config.url + ' will be loaded after login is successful');\n\t            delayedRequest = $q.defer();\n\t            $rootScope.$on('salte-auth:loginSuccess', function (event, token) {\n\t              if (token) {\n\t                salteAuthService.info('Login completed, sending request for ' + config.url);\n\t                config.headers.Authorization = 'Bearer ' + tokenStored;\n\t                delayedRequest.resolve(config);\n\t              }\n\t            });\n\t            return delayedRequest.promise;\n\t          }\n\t\n\t          salteAuthService.info('login is in progress.');\n\t          config.data = 'login in progress, cancelling the request for ' + config.url;\n\t          return $q.reject(config);\n\t        }\n\t\n\t        // delayed request to return after iframe completes\n\t        delayedRequest = $q.defer();\n\t        salteAuthService.acquireToken(resource).then(function (token) {\n\t          salteAuthService.verbose('Token is available');\n\t          config.headers.Authorization = 'Bearer ' + token;\n\t          delayedRequest.resolve(config);\n\t        }, function (err) {\n\t          config.data = err;\n\t          delayedRequest.reject(config);\n\t        });\n\t\n\t        return delayedRequest.promise;\n\t      }\n\t    },\n\t    responseError: function responseError(rejection) {\n\t      salteAuthService.info('Getting error in the response.');\n\t      if (rejection) {\n\t        if (rejection.status === 401) {\n\t          var resource = salteAuthService.getResourceForEndpoint(rejection.config.url);\n\t          salteAuthService.clearCacheForResource(resource);\n\t          $rootScope.$broadcast('salte-auth:notAuthorized', rejection, resource);\n\t        } else {\n\t          $rootScope.$broadcast('salte-auth:errorResponse', rejection);\n\t        }\n\t        return $q.reject(rejection);\n\t      }\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function () {\n\t  var salteAuth = null;\n\t  var _oauthData = {\n\t    isAuthenticated: false,\n\t    userName: '',\n\t    loginError: '',\n\t    profile: ''\n\t  };\n\t\n\t  var updateDataFromCache = function updateDataFromCache(resource) {\n\t    // only cache lookup here to not interrupt with events\n\t    var token = salteAuth.getCachedToken(resource);\n\t    _oauthData.isAuthenticated = token !== null && token.length > 0;\n\t    var user = salteAuth.getCachedUser() || {\n\t      userName: ''\n\t    };\n\t    _oauthData.userName = user.userName;\n\t    _oauthData.profile = user.profile;\n\t    _oauthData.loginError = salteAuth.getLoginError();\n\t  };\n\t\n\t  this.init = function (configOptions, httpProvider) {\n\t    if (configOptions) {\n\t      // redirect and logout_redirect are set to current location by default\n\t      var existingHash = window.location.hash;\n\t      var pathDefault = window.location.href;\n\t      if (existingHash) {\n\t        pathDefault = pathDefault.replace(existingHash, '');\n\t      }\n\t      configOptions.redirectUri = configOptions.redirectUri || pathDefault;\n\t      configOptions.postLogoutRedirectUri = configOptions.postLogoutRedirectUri || pathDefault;\n\t      configOptions.isAngular = true;\n\t\n\t      if (httpProvider && httpProvider.interceptors) {\n\t        httpProvider.interceptors.push('ProtectedResourceInterceptor');\n\t      }\n\t\n\t      // create instance with given config\n\t      salteAuth = new _salteAuth2.default(configOptions);\n\t    } else {\n\t      throw new Error('You must set configOptions, when calling init');\n\t    }\n\t\n\t    // loginResource is used to set authenticated status\n\t    updateDataFromCache(salteAuth.config.loginResource);\n\t  };\n\t\n\t  /* @ngInject */\n\t  this.$get = function SalteAuthService($rootScope, $window, $q, $location, $timeout, $injector) {\n\t    var locationChangeHandler = function locationChangeHandler(event, newUrl, oldUrl) {\n\t      salteAuth.verbose('Location change event from ' + oldUrl + ' to ' + newUrl);\n\t      var hash = $window.location.hash;\n\t      var search = $window.location.search;\n\t\n\t      if (salteAuth.isCallback(hash, search)) {\n\t        // callback can come from login or iframe request\n\t        salteAuth.verbose('Processing Callback, Hash: ' + hash + '; Search String: ' + search);\n\t        var requestInfo = salteAuth.getRequestInfo(hash, search);\n\t        salteAuth.saveTokenFromHash(requestInfo);\n\t\n\t        // Return to callback if it is sent from iframe\n\t        if (requestInfo.stateMatch) {\n\t          if (requestInfo.requestType === salteAuth.REQUEST_TYPE.RENEW_TOKEN) {\n\t            var callback = $window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t            // since this is a token renewal request in iFrame, we don't need to proceed with the location change.\n\t            event.preventDefault();\n\t\n\t            // Call within the same context without full page redirect keeps the callback\n\t            if (callback && typeof callback === 'function') {\n\t              // id_token or access_token can be renewed\n\t              if (requestInfo.parameters.access_token) {\n\t                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.access_token);\n\t                return;\n\t              } else if (requestInfo.parameters.id_token) {\n\t                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.id_token);\n\t                return;\n\t              } else if (requestInfo.parameters.error) {\n\t                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), null);\n\t                return;\n\t              }\n\t            }\n\t          } else if (requestInfo.requestType === salteAuth.REQUEST_TYPE.LOGIN) {\n\t            // normal full login redirect happened on the page\n\t            updateDataFromCache(salteAuth.config.loginResource);\n\t            if (_oauthData.userName) {\n\t              $timeout(function () {\n\t                // id_token is added as token for the app\n\t                updateDataFromCache(salteAuth.config.loginResource);\n\t                $rootScope.userInfo = _oauthData;\n\t              }, 1);\n\t\n\t              $rootScope.$broadcast('salte-auth:loginSuccess', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n\t            } else {\n\t              $rootScope.$broadcast('salte-auth:loginFailure', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n\t            }\n\t\n\t            if (salteAuth.callback && typeof salteAuth.callback === 'function') {\n\t              salteAuth.callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n\t            }\n\t\n\t            // redirect to login start page\n\t            if (!salteAuth.popUp) {\n\t              var loginStartPage = salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.LOGIN_REQUEST);\n\t              if (typeof loginStartPage !== 'undefined' && loginStartPage && loginStartPage.length !== 0) {\n\t                // prevent the current location change and redirect the user back to the login start page\n\t                salteAuth.verbose('Redirecting to start page: ' + loginStartPage);\n\t                if (!$location.$$html5 && loginStartPage.indexOf('#') > -1) {\n\t                  $location.url(loginStartPage.substring(loginStartPage.indexOf('#') + 1));\n\t                }\n\t                $window.location = loginStartPage;\n\t              }\n\t            } else {\n\t              event.preventDefault();\n\t            }\n\t          }\n\t        } else {\n\t          // state did not match, broadcast an error\n\t          $rootScope.$broadcast('salte-auth:stateMismatch', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n\t        }\n\t      } else {\n\t        // No callback. App resumes after closing or moving to new page.\n\t        // Check token and username\n\t        updateDataFromCache(salteAuth.config.loginResource);\n\t        if (!_oauthData.isAuthenticated && _oauthData.userName && !salteAuth._renewActive) {\n\t          // id_token is expired or not present\n\t          salteAuth._renewActive = true;\n\t          salteAuth.acquireToken(salteAuth.config.loginResource, function (error, tokenOut) {\n\t            salteAuth._renewActive = false;\n\t            if (error) {\n\t              $rootScope.$broadcast('salte-auth:loginFailure', 'auto renew failure');\n\t            } else if (tokenOut) {\n\t              _oauthData.isAuthenticated = true;\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      $timeout(function () {\n\t        updateDataFromCache(salteAuth.config.loginResource);\n\t        $rootScope.userInfo = _oauthData;\n\t      }, 1);\n\t    };\n\t\n\t    var loginHandler = function loginHandler() {\n\t      salteAuth.info('Login event for:' + $location.$$url);\n\t      if (salteAuth.config && salteAuth.config.localLoginUrl) {\n\t        $location.path(salteAuth.config.localLoginUrl);\n\t      } else {\n\t        // directly start login flow\n\t        salteAuth.info('Start login at:' + window.location.href);\n\t        $rootScope.$broadcast('salte-auth:loginRedirect');\n\t        salteAuth.login($location.absUrl());\n\t      }\n\t    };\n\t\n\t    function isADLoginRequired(route, global) {\n\t      return global.requireADLogin ? route.requireADLogin !== false : Boolean(route.requireADLogin);\n\t    }\n\t\n\t    function isAnonymousEndpoint(url) {\n\t      if (salteAuth.config && salteAuth.config.anonymousEndpoints) {\n\t        for (var i = 0; i < salteAuth.config.anonymousEndpoints.length; i++) {\n\t          if (url.indexOf(salteAuth.config.anonymousEndpoints[i]) > -1) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t\n\t    function getStates(toState) {\n\t      var state = null;\n\t      var states = [];\n\t      if (toState.hasOwnProperty('parent')) {\n\t        state = toState;\n\t        while (state) {\n\t          states.unshift(state);\n\t          state = $injector.get('$state').get(state.parent);\n\t        }\n\t      } else {\n\t        var stateNames = toState.name.split('.');\n\t        for (var i = 0, stateName = stateNames[0]; i < stateNames.length; i++) {\n\t          state = $injector.get('$state').get(stateName);\n\t          if (state) {\n\t            states.push(state);\n\t          }\n\t          stateName += '.' + stateNames[i + 1];\n\t        }\n\t      }\n\t      return states;\n\t    }\n\t\n\t    var routeChangeHandler = function routeChangeHandler(e, nextRoute) {\n\t      if (nextRoute && nextRoute.$$route) {\n\t        if (isADLoginRequired(nextRoute.$$route, salteAuth.config)) {\n\t          if (!_oauthData.isAuthenticated) {\n\t            if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n\t              salteAuth.info('Route change event for:' + $location.$$url);\n\t              loginHandler();\n\t            }\n\t          }\n\t        } else {\n\t          var nextRouteUrl;\n\t          if (typeof nextRoute.$$route.templateUrl === 'function') {\n\t            nextRouteUrl = nextRoute.$$route.templateUrl(nextRoute.params);\n\t          } else {\n\t            nextRouteUrl = nextRoute.$$route.templateUrl;\n\t          }\n\t\n\t          if (nextRouteUrl && !isAnonymousEndpoint(nextRouteUrl)) {\n\t            salteAuth.config.anonymousEndpoints.push(nextRouteUrl);\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var stateChangeHandler = function stateChangeHandler(e, toState, toParams, fromState, fromParams) {\n\t      // jshint ignore:line\n\t      if (toState) {\n\t        var states = getStates(toState);\n\t        var state = null;\n\t        for (var i = 0; i < states.length; i++) {\n\t          state = states[i];\n\t          if (isADLoginRequired(state, salteAuth.config)) {\n\t            if (!_oauthData.isAuthenticated) {\n\t              if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n\t                salteAuth.info('State change event for:' + $location.$$url);\n\t                loginHandler();\n\t              }\n\t            }\n\t          } else if (state.templateUrl) {\n\t            var nextStateUrl;\n\t            if (typeof state.templateUrl === 'function') {\n\t              nextStateUrl = state.templateUrl(toParams);\n\t            } else {\n\t              nextStateUrl = state.templateUrl;\n\t            }\n\t            if (nextStateUrl && !isAnonymousEndpoint(nextStateUrl)) {\n\t              salteAuth.config.anonymousEndpoints.push(nextStateUrl);\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var stateChangeErrorHandler = function stateChangeErrorHandler(event, toState, toParams, fromState, fromParams, error) {\n\t      salteAuth.verbose('State change error occured. Error: ' + error);\n\t\n\t      if (error && error.data) {\n\t        salteAuth.info('Setting defaultPrevented to true if state change error occured because the request was rejected. Error: ' + error.data);\n\t        event.preventDefault();\n\t      }\n\t    };\n\t\n\t    // Route change event tracking to receive fragment and also auto renew tokens\n\t    $rootScope.$on('$routeChangeStart', routeChangeHandler);\n\t\n\t    $rootScope.$on('$stateChangeStart', stateChangeHandler);\n\t\n\t    $rootScope.$on('$locationChangeStart', locationChangeHandler);\n\t\n\t    $rootScope.$on('$stateChangeError', stateChangeErrorHandler);\n\t\n\t    updateDataFromCache(salteAuth.config.loginResource);\n\t    $rootScope.userInfo = _oauthData;\n\t\n\t    return {\n\t      // public methods will be here that are accessible from Controller\n\t      config: salteAuth.config,\n\t      login: function login() {\n\t        loginHandler();\n\t      },\n\t      loginInProgress: function loginInProgress() {\n\t        return salteAuth.loginInProgress();\n\t      },\n\t      logOut: function logOut() {\n\t        salteAuth.logOut();\n\t        // call signout related method\n\t      },\n\t      getCachedToken: function getCachedToken(resource) {\n\t        return salteAuth.getCachedToken(resource);\n\t      },\n\t      userInfo: _oauthData,\n\t      acquireToken: function acquireToken(resource) {\n\t        // automated token request call\n\t        var deferred = $q.defer();\n\t        salteAuth._renewActive = true;\n\t        salteAuth.acquireToken(resource, function (error, tokenOut) {\n\t          salteAuth._renewActive = false;\n\t          if (error) {\n\t            salteAuth.error('Error when acquiring token for resource: ' + resource, error);\n\t            deferred.reject(error);\n\t          } else {\n\t            deferred.resolve(tokenOut);\n\t          }\n\t        });\n\t\n\t        return deferred.promise;\n\t      },\n\t      getUser: function getUser() {\n\t        var deferred = $q.defer();\n\t        salteAuth.getUser(function (error, user) {\n\t          if (error) {\n\t            salteAuth.error('Error when getting user', error);\n\t            deferred.reject(error);\n\t          } else {\n\t            deferred.resolve(user);\n\t          }\n\t        });\n\t\n\t        return deferred.promise;\n\t      },\n\t      getResourceForEndpoint: function getResourceForEndpoint(endpoint) {\n\t        return salteAuth.getResourceForEndpoint(endpoint);\n\t      },\n\t      clearCache: function clearCache() {\n\t        salteAuth.clearCache();\n\t      },\n\t      clearCacheForResource: function clearCacheForResource(resource) {\n\t        salteAuth.clearCacheForResource(resource);\n\t      },\n\t      info: function info(message) {\n\t        salteAuth.info(message);\n\t      },\n\t      verbose: function verbose(message) {\n\t        salteAuth.verbose(message);\n\t      },\n\t      salteAuth: salteAuth\n\t    };\n\t  };\n\t  this.$get.$inject = [\"$rootScope\", \"$window\", \"$q\", \"$location\", \"$timeout\", \"$injector\"];\n\t};\n\t\n\tvar _salteAuth = __webpack_require__(4);\n\n\tvar _salteAuth2 = _interopRequireDefault(_salteAuth);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth-angular.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0e498030639eee14a244\n **/","import angular from 'angular';\nimport ProtectedResourceInterceptor from './protected-resource-interceptor.factory.js';\nimport salteAuthService from './salte-auth.provider.js';\n\nconst module = angular.module('salte.auth-angular', []);\n\nmodule.factory('ProtectedResourceInterceptor', ProtectedResourceInterceptor);\nmodule.provider('salteAuthService', salteAuthService);\n\nexport default module.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth-angular.module.js\n **/","/* @ngInject */\nexport default function ProtectedResourceInterceptor(salteAuthService, $q, $rootScope) {\n  return {\n    request: function(config) {\n      if (config) {\n        config.headers = config.headers || {};\n        var resource = salteAuthService.getResourceForEndpoint(config.url);\n        salteAuthService.verbose('Url: ' + config.url + ' maps to resource: ' + resource);\n\n        if (resource === null) {\n          return config;\n        }\n\n        var tokenStored = salteAuthService.getCachedToken(resource);\n        if (tokenStored) {\n          salteAuthService.info('Token is available for this url ' + config.url);\n          // check endpoint mapping if provided\n          config.headers.Authorization = 'Bearer ' + tokenStored;\n          return config;\n        }\n\n        // Cancel request if login is starting\n        var delayedRequest;\n        if (salteAuthService.loginInProgress()) {\n          if (salteAuthService.config.popUp) {\n            salteAuthService.info('Url: ' + config.url + ' will be loaded after login is successful');\n            delayedRequest = $q.defer();\n            $rootScope.$on('salte-auth:loginSuccess', function(event, token) {\n              if (token) {\n                salteAuthService.info('Login completed, sending request for ' + config.url);\n                config.headers.Authorization = 'Bearer ' + tokenStored;\n                delayedRequest.resolve(config);\n              }\n            });\n            return delayedRequest.promise;\n          }\n\n          salteAuthService.info('login is in progress.');\n          config.data = 'login in progress, cancelling the request for ' + config.url;\n          return $q.reject(config);\n        }\n\n        // delayed request to return after iframe completes\n        delayedRequest = $q.defer();\n        salteAuthService.acquireToken(resource).then(function(token) {\n          salteAuthService.verbose('Token is available');\n          config.headers.Authorization = 'Bearer ' + token;\n          delayedRequest.resolve(config);\n        }, function(err) {\n          config.data = err;\n          delayedRequest.reject(config);\n        });\n\n        return delayedRequest.promise;\n      }\n    },\n    responseError: function(rejection) {\n      salteAuthService.info('Getting error in the response.');\n      if (rejection) {\n        if (rejection.status === 401) {\n          var resource = salteAuthService.getResourceForEndpoint(rejection.config.url);\n          salteAuthService.clearCacheForResource(resource);\n          $rootScope.$broadcast('salte-auth:notAuthorized', rejection, resource);\n        } else {\n          $rootScope.$broadcast('salte-auth:errorResponse', rejection);\n        }\n        return $q.reject(rejection);\n      }\n    }\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./protected-resource-interceptor.factory.js\n **/","import SalteAuth from 'salte-auth';\n\nexport default function() {\n  var salteAuth = null;\n  var _oauthData = {\n    isAuthenticated: false,\n    userName: '',\n    loginError: '',\n    profile: ''\n  };\n\n  var updateDataFromCache = function(resource) {\n    // only cache lookup here to not interrupt with events\n    var token = salteAuth.getCachedToken(resource);\n    _oauthData.isAuthenticated = token !== null && token.length > 0;\n    var user = salteAuth.getCachedUser() || {\n      userName: ''\n    };\n    _oauthData.userName = user.userName;\n    _oauthData.profile = user.profile;\n    _oauthData.loginError = salteAuth.getLoginError();\n  };\n\n  this.init = function(configOptions, httpProvider) {\n    if (configOptions) {\n      // redirect and logout_redirect are set to current location by default\n      var existingHash = window.location.hash;\n      var pathDefault = window.location.href;\n      if (existingHash) {\n        pathDefault = pathDefault.replace(existingHash, '');\n      }\n      configOptions.redirectUri = configOptions.redirectUri || pathDefault;\n      configOptions.postLogoutRedirectUri = configOptions.postLogoutRedirectUri || pathDefault;\n      configOptions.isAngular = true;\n\n      if (httpProvider && httpProvider.interceptors) {\n        httpProvider.interceptors.push('ProtectedResourceInterceptor');\n      }\n\n      // create instance with given config\n      salteAuth = new SalteAuth(configOptions);\n    } else {\n      throw new Error('You must set configOptions, when calling init');\n    }\n\n    // loginResource is used to set authenticated status\n    updateDataFromCache(salteAuth.config.loginResource);\n  };\n\n  /* @ngInject */\n  this.$get = function SalteAuthService($rootScope, $window, $q, $location, $timeout, $injector) {\n    var locationChangeHandler = function(event, newUrl, oldUrl) {\n      salteAuth.verbose('Location change event from ' + oldUrl + ' to ' + newUrl);\n      var hash = $window.location.hash;\n      var search = $window.location.search;\n\n      if (salteAuth.isCallback(hash, search)) {\n        // callback can come from login or iframe request\n        salteAuth.verbose('Processing Callback, Hash: ' + hash + '; Search String: ' + search);\n        var requestInfo = salteAuth.getRequestInfo(hash, search);\n        salteAuth.saveTokenFromHash(requestInfo);\n\n        // Return to callback if it is sent from iframe\n        if (requestInfo.stateMatch) {\n          if (requestInfo.requestType === salteAuth.REQUEST_TYPE.RENEW_TOKEN) {\n            var callback = $window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n            // since this is a token renewal request in iFrame, we don't need to proceed with the location change.\n            event.preventDefault();\n\n            // Call within the same context without full page redirect keeps the callback\n            if (callback && typeof callback === 'function') {\n              // id_token or access_token can be renewed\n              if (requestInfo.parameters.access_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.access_token);\n                return;\n              } else if (requestInfo.parameters.id_token) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters.id_token);\n                return;\n              } else if (requestInfo.parameters.error) {\n                callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), null);\n                return;\n              }\n            }\n          } else if (requestInfo.requestType === salteAuth.REQUEST_TYPE.LOGIN) {\n            // normal full login redirect happened on the page\n            updateDataFromCache(salteAuth.config.loginResource);\n            if (_oauthData.userName) {\n              $timeout(function() {\n                // id_token is added as token for the app\n                updateDataFromCache(salteAuth.config.loginResource);\n                $rootScope.userInfo = _oauthData;\n              }, 1);\n\n              $rootScope.$broadcast('salte-auth:loginSuccess', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            } else {\n              $rootScope.$broadcast('salte-auth:loginFailure', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n            }\n\n            if (salteAuth.callback && typeof salteAuth.callback === 'function') {\n              salteAuth.callback(salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION), salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.IDTOKEN));\n            }\n\n            // redirect to login start page\n            if (!salteAuth.popUp) {\n              var loginStartPage = salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.LOGIN_REQUEST);\n              if (typeof loginStartPage !== 'undefined' && loginStartPage && loginStartPage.length !== 0) {\n                // prevent the current location change and redirect the user back to the login start page\n                salteAuth.verbose('Redirecting to start page: ' + loginStartPage);\n                if (!$location.$$html5 && loginStartPage.indexOf('#') > -1) {\n                  $location.url(loginStartPage.substring(loginStartPage.indexOf('#') + 1));\n                }\n                $window.location = loginStartPage;\n              }\n            } else {\n              event.preventDefault();\n            }\n          }\n        } else {\n          // state did not match, broadcast an error\n          $rootScope.$broadcast('salte-auth:stateMismatch', salteAuth._getItem(salteAuth.CONSTANTS.STORAGE.ERROR_DESCRIPTION));\n        }\n      } else {\n        // No callback. App resumes after closing or moving to new page.\n        // Check token and username\n        updateDataFromCache(salteAuth.config.loginResource);\n        if (!_oauthData.isAuthenticated && _oauthData.userName && !salteAuth._renewActive) {\n          // id_token is expired or not present\n          salteAuth._renewActive = true;\n          salteAuth.acquireToken(salteAuth.config.loginResource, function(error, tokenOut) {\n            salteAuth._renewActive = false;\n            if (error) {\n              $rootScope.$broadcast('salte-auth:loginFailure', 'auto renew failure');\n            } else if (tokenOut) {\n              _oauthData.isAuthenticated = true;\n            }\n          });\n        }\n      }\n\n      $timeout(function() {\n        updateDataFromCache(salteAuth.config.loginResource);\n        $rootScope.userInfo = _oauthData;\n      }, 1);\n    };\n\n    var loginHandler = function() {\n      salteAuth.info('Login event for:' + $location.$$url);\n      if (salteAuth.config && salteAuth.config.localLoginUrl) {\n        $location.path(salteAuth.config.localLoginUrl);\n      } else {\n        // directly start login flow\n        salteAuth.info('Start login at:' + window.location.href);\n        $rootScope.$broadcast('salte-auth:loginRedirect');\n        salteAuth.login($location.absUrl());\n      }\n    };\n\n    function isADLoginRequired(route, global) {\n      return global.requireADLogin ? route.requireADLogin !== false : Boolean(route.requireADLogin);\n    }\n\n    function isAnonymousEndpoint(url) {\n      if (salteAuth.config && salteAuth.config.anonymousEndpoints) {\n        for (var i = 0; i < salteAuth.config.anonymousEndpoints.length; i++) {\n          if (url.indexOf(salteAuth.config.anonymousEndpoints[i]) > -1) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function getStates(toState) {\n      var state = null;\n      var states = [];\n      if (toState.hasOwnProperty('parent')) {\n        state = toState;\n        while (state) {\n          states.unshift(state);\n          state = $injector.get('$state').get(state.parent);\n        }\n      } else {\n        var stateNames = toState.name.split('.');\n        for (var i = 0, stateName = stateNames[0]; i < stateNames.length; i++) {\n          state = $injector.get('$state').get(stateName);\n          if (state) {\n            states.push(state);\n          }\n          stateName += '.' + stateNames[i + 1];\n        }\n      }\n      return states;\n    }\n\n    var routeChangeHandler = function(e, nextRoute) {\n      if (nextRoute && nextRoute.$$route) {\n        if (isADLoginRequired(nextRoute.$$route, salteAuth.config)) {\n          if (!_oauthData.isAuthenticated) {\n            if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n              salteAuth.info('Route change event for:' + $location.$$url);\n              loginHandler();\n            }\n          }\n        } else {\n          var nextRouteUrl;\n          if (typeof nextRoute.$$route.templateUrl === 'function') {\n            nextRouteUrl = nextRoute.$$route.templateUrl(nextRoute.params);\n          } else {\n            nextRouteUrl = nextRoute.$$route.templateUrl;\n          }\n\n          if (nextRouteUrl && !isAnonymousEndpoint(nextRouteUrl)) {\n            salteAuth.config.anonymousEndpoints.push(nextRouteUrl);\n          }\n        }\n      }\n    };\n\n    var stateChangeHandler = function(e, toState, toParams, fromState, fromParams) { // jshint ignore:line\n      if (toState) {\n        var states = getStates(toState);\n        var state = null;\n        for (var i = 0; i < states.length; i++) {\n          state = states[i];\n          if (isADLoginRequired(state, salteAuth.config)) {\n            if (!_oauthData.isAuthenticated) {\n              if (!salteAuth._renewActive && !salteAuth.loginInProgress()) {\n                salteAuth.info('State change event for:' + $location.$$url);\n                loginHandler();\n              }\n            }\n          } else if (state.templateUrl) {\n            var nextStateUrl;\n            if (typeof state.templateUrl === 'function') {\n              nextStateUrl = state.templateUrl(toParams);\n            } else {\n              nextStateUrl = state.templateUrl;\n            }\n            if (nextStateUrl && !isAnonymousEndpoint(nextStateUrl)) {\n              salteAuth.config.anonymousEndpoints.push(nextStateUrl);\n            }\n          }\n        }\n      }\n    };\n\n    var stateChangeErrorHandler = function(event, toState, toParams, fromState, fromParams, error) {\n      salteAuth.verbose('State change error occured. Error: ' + error);\n\n      if (error && error.data) {\n        salteAuth.info('Setting defaultPrevented to true if state change error occured because the request was rejected. Error: ' + error.data);\n        event.preventDefault();\n      }\n    };\n\n    // Route change event tracking to receive fragment and also auto renew tokens\n    $rootScope.$on('$routeChangeStart', routeChangeHandler);\n\n    $rootScope.$on('$stateChangeStart', stateChangeHandler);\n\n    $rootScope.$on('$locationChangeStart', locationChangeHandler);\n\n    $rootScope.$on('$stateChangeError', stateChangeErrorHandler);\n\n    updateDataFromCache(salteAuth.config.loginResource);\n    $rootScope.userInfo = _oauthData;\n\n    return {\n      // public methods will be here that are accessible from Controller\n      config: salteAuth.config,\n      login: function() {\n        loginHandler();\n      },\n      loginInProgress: function() {\n        return salteAuth.loginInProgress();\n      },\n      logOut: function() {\n        salteAuth.logOut();\n        // call signout related method\n      },\n      getCachedToken: function(resource) {\n        return salteAuth.getCachedToken(resource);\n      },\n      userInfo: _oauthData,\n      acquireToken: function(resource) {\n        // automated token request call\n        var deferred = $q.defer();\n        salteAuth._renewActive = true;\n        salteAuth.acquireToken(resource, function(error, tokenOut) {\n          salteAuth._renewActive = false;\n          if (error) {\n            salteAuth.error('Error when acquiring token for resource: ' + resource, error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(tokenOut);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getUser: function() {\n        var deferred = $q.defer();\n        salteAuth.getUser(function(error, user) {\n          if (error) {\n            salteAuth.error('Error when getting user', error);\n            deferred.reject(error);\n          } else {\n            deferred.resolve(user);\n          }\n        });\n\n        return deferred.promise;\n      },\n      getResourceForEndpoint: function(endpoint) {\n        return salteAuth.getResourceForEndpoint(endpoint);\n      },\n      clearCache: function() {\n        salteAuth.clearCache();\n      },\n      clearCacheForResource: function(resource) {\n        salteAuth.clearCacheForResource(resource);\n      },\n      info: function(message) {\n        salteAuth.info(message);\n      },\n      verbose: function(message) {\n        salteAuth.verbose(message);\n      },\n      salteAuth: salteAuth\n    };\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.provider.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\",\"amd\":\"angular\"}\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"salte-auth\",\"commonjs2\":\"salte-auth\",\"commonjs\":\"salte-auth\",\"amd\":\"salte-auth\"}\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}
